<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clicker Game</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bungee">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #87CEEB;
        }

        .canvas-container {
            position: relative;
            width: 400px; /* Adjust as needed */
            height: 600px; /* Adjust as needed */
            display: flex;
            flex-direction: column; /* Stack children vertically */
            justify-content: center; /* Align children to the center */
            align-items: center;
        }

        canvas {
            background: #8B4513;
        }

        .save {
            width: 100%;
            font-size: 20px;
            font-family: 'Bungee', sans-serif;
            color: white;
            background-color: #007BFF;
            border: none;
            cursor: pointer;
            text-align: center;
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelector('.save').onclick = save;
        });

        function save() {
            fetch('/save', {
                method: 'POST',
                body: JSON.stringify({
                    counter: clickCount
                })
            })
            .then(response => response.json())
            .then(result => {
                // Handle response if needed
            });   
        }
    </script>
</head>
<body>

    <h1 class="counter" style="display:none">{{counter}}</h1>

    <div class="canvas-container">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <button class="save">Save</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Load background image
        const backgroundImage = new Image();
        backgroundImage.src = "https://i.ibb.co/cNSkNLf/image.png";  // Replace with the path to your image

        // Load falling image
        const fallingImage = new Image();
        fallingImage.src = "https://i.ibb.co/HCfX5Df/banner.png";  // Replace with the path to your image

        // Game variables
        const gameWidth = canvas.width;
        const gameHeight = canvas.height;
        let clickCount = Number(document.querySelector('.counter').innerHTML);
        let fallingY = -gameHeight; // Start position above the canvas
        const fallingSpeed = 2;
        const particles = [];

        // Particle class
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 48; // Size matching counter text size
                this.speedX = (Math.random() - 0.5) * 8; // Chaotic speed in x direction
                this.speedY = (Math.random() - 0.5) * 8; // Chaotic speed in y direction
                this.color = 'gold'; // Color of the particle
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                // Remove particle if it goes beyond canvas boundaries
                if (this.x < 0 || this.x > gameWidth || this.y < 0 || this.y > gameHeight) {
                    return true; // Signal to remove this particle from the array
                }

                return false; // Particle is still within canvas boundaries
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.font = `${this.size}px Bungee`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', this.x, this.y);
            }
        }

        // Draw counter
        function drawCounter() {
            ctx.fillStyle = 'gold'; // Set text color to gold
            ctx.font = '100px Bungee'; // Increase font size to 100px Bungee
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(clickCount, gameWidth / 2, gameHeight / 2);
        }

        // Animate counter jump
        function animateCounterJump() {
            let jumpDistance = 30; // Adjust the jump distance as needed
            let originalY = gameHeight / 2; // Original y position of the counter
            let jumpFrames = 15; // Number of frames for the jump animation
            let frame = 0;

            // Function to animate the jump
            function animate() {
                frame++;
                if (frame <= jumpFrames) {
                    // Calculate current y position with jump effect
                    let deltaY = Math.sin((frame / jumpFrames) * Math.PI) * jumpDistance;
                    ctx.clearRect(0, 0, gameWidth, gameHeight); // Clear canvas
                    drawBackground(); // Redraw background (if needed)
                    drawFallingImage(); // Redraw falling image (if needed)
                    drawParticles(); // Redraw particles (if needed)
                    drawCounterJump(originalY + deltaY); // Draw counter with jump effect
                    requestAnimationFrame(animate);
                }
            }

            // Start the animation
            animate();
        }

        // Draw counter jump
        function drawCounterJump(y) {
            ctx.fillStyle = 'gold'; // Set text color to gold
            ctx.font = '100px Bungee'; // Font size and family should match drawCounter()
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(clickCount, gameWidth / 2, y);
        }

        // Clear canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, gameWidth, gameHeight);
        }

        // Draw background
        function drawBackground() {
            ctx.drawImage(backgroundImage, 0, 0, gameWidth, gameHeight);
        }

        // Draw falling image with transparency
        function drawFallingImage() {
            ctx.globalAlpha = 0.5; // Set transparency to 50%
            ctx.drawImage(fallingImage, 0, fallingY, gameWidth, fallingImage.height * (gameWidth / fallingImage.width));
            ctx.globalAlpha = 1.0; // Reset transparency
        }

        // Update game objects
        function update() {
            fallingY += fallingSpeed;

            if (fallingY > gameHeight) {
                fallingY = -fallingImage.height * (gameWidth / fallingImage.width); // Reset to start position
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].update()) {
                    particles.splice(i, 1); // Remove particle if it goes out of bounds
                }
            }
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(particle => {
                particle.draw();
            });
        }

        // Game loop
        function gameLoop() {
            clearCanvas();
            drawBackground();
            update();
            drawFallingImage();
            drawCounter();
            drawParticles();
            requestAnimationFrame(gameLoop);
        }

        // Start game loop when the images are loaded
        backgroundImage.onload = function() {
            fallingImage.onload = function() {
                // Start the game loop
                gameLoop();
            };
        };

        // Canvas click event
        canvas.addEventListener('click', (e) => {
            clickCount++;
            animateCounterJump(); // Trigger counter jump animation
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            for (let i = 0; i < 5; i++) { // Reduced number of particles
                particles.push(new Particle(x, y));
            }
        });
    </script>
</body>
</html>
